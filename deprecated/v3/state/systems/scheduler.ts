/**
 * Reactive Systems Scheduler
 * 
 * Analyzes patches from the GM to determine if time has passed,
 * and if so, runs the appropriate systems from the registry.
 */

import type { SimpleWorld } from '../world';
import type { Patch } from '../../tools/types';
import { SYSTEM_REGISTRY } from './framework';
import { applyPatches } from '../arbiter';

/**
 * Computes additional patches from reactive systems based on the GM's changes.
 * 
 * @param worldBefore - The state of the world *before* the GM's turn
 * @param gmPatches - The patches the GM wants to apply (must include time updates for systems to trigger)
 * @returns A list of new patches generated by the systems
 */
export function computeSystemPatches(
  worldBefore: SimpleWorld,
  gmPatches: Patch[]
): Patch[] {
  const systemPatches: Patch[] = [];
  
  // 1. Detect Time Change
  // We look for a patch that sets the elapsedMinutes
  const timePatch = gmPatches.find(p => p.path === '/systems/time/elapsedMinutes' && p.op === 'set');
  
  // If time didn't change, we assume only per_action systems *might* run, 
  // but for now we only focus on time-driven systems.
  if (!timePatch || typeof timePatch.value !== 'number') return [];

  const prevTime = worldBefore.systems?.time?.elapsedMinutes ?? 0;
  const newTime = timePatch.value;
  const timeDelta = newTime - prevTime;

  // If time didn't move forward, do nothing
  if (timeDelta <= 0) return [];
  
  // 2. Determine Boundaries
  const prevHour = Math.floor(prevTime / 60);
  const newHour = Math.floor(newTime / 60);
  const crossedHour = newHour > prevHour;
  
  const prevDay = Math.floor(prevTime / (60 * 24));
  const newDay = Math.floor(newTime / (60 * 24));
  const crossedDay = newDay > prevDay;

  // 3. Simulate the world "after GM" but "before systems"
  // We need to pass the world *with* the new time to the systems,
  // so they calculate based on the new timestamp (e.g., "It is now 2 PM, calculate tide").
  // We apply the GM patches tentatively to a clone to get this state.
  const worldAfterGM = applyPatches(worldBefore, gmPatches);

  // 4. Run Systems
  for (const sys of SYSTEM_REGISTRY.values()) {
    let shouldRun = false;

    if (sys.tickRate === 'per_action') shouldRun = true;
    if (sys.tickRate === 'hourly' && crossedHour) shouldRun = true;
    if (sys.tickRate === 'daily' && crossedDay) shouldRun = true;

    if (shouldRun) {
      try {
        const patches = sys.reducer(worldAfterGM, { timeDelta, worldAfterGM });
        
        // Tag patches with the system ID for provenance
        const taggedPatches = patches.map(p => ({
          ...p,
          by: sys.id, // Tag who made this change
        }));

        systemPatches.push(...taggedPatches);
      } catch (err) {
        console.error(`System '${sys.id}' failed:`, err);
      }
    }
  }
  
  return systemPatches;
}

